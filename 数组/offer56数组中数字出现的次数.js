/*一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。
请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。*/

/*解题思路：
* 1.先对所有数字进行一次异或，得到连个出现一次的数字的异或值
* 2.在异或结果中找到任意为1的位
* 3.根据这一位对所有的数字进行分组
* 4.在每个组内进行异或操作，得到两个数字*/

/*
异或的性质：
不同为1，相同为0；一个数和相同的数异或两次就是它本身；0跟哪个数异或就得到哪个数


通过 & 运算来判断一位数字不同即可分为两组，
那么我们随便两个不同的数字至少也有一位不同*/
var nums = nums = [4,1,4,6]
/*关键点在分组上： 4 ->100 ；1 ->001； 6 ->110； 4 ->100 ；
所有数字异或值为 k（这里是111），只要找到一个k中，位数为1的任意位号mask
（ 这里用的是 while((k & mask) == 0) { mask <<= 1; } ），
显然第一位就是mask，mask这个位号表示的是那两个不重复数的二进制（001、110）在这个位号上不同时为0或1的位置，那么锁定这样的位置后，
以同样方法（使用(num & mask) == 0），将mask位不为1的剔出来为一组，而另一组中必然会有mask位为1的数，
这样就实现了不重复的两个数分到了不同组，而那些重复数必然被分到相同的组中，最终被抵消。*/
function singleNumbers(nums){
    let sum=0
    for (let i=0;i<nums.length;i++){
        sum^=nums[i]/*sum的值就是两个数异或操作的结果值*/
    }
//    sum=000
    let flag=1
    while((flag&sum)===0)
    flag<<=1
    let res= new Array(2).fill(0)
    for (let i=0;i<nums.length;i++){
        if ((nums[i]&flag)===0){
            res[0]=nums[i]
        }else {
            res[1]=nums[i]
        }
    }
    return res
}

console.log(singleNumbers(nums))